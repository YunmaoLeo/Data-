# Menu
- [Menu](#menu)
- [初级排序](#初级排序)
  - [插入排序](#插入排序)
    - [定义](#定义)
    - [命题](#命题)
    - [实现](#实现)
    - [优化](#优化)
  - [希尔排序](#希尔排序)
    - [定义](#定义-1)
    - [特点](#特点)
    - [实现](#实现-1)
  - [归并排序](#归并排序)
    - [定义](#定义-2)
    - [原地归并](#原地归并)
    - [自顶向下的归并排序](#自顶向下的归并排序)
    - [自底向上的归并排序](#自底向上的归并排序)
    - [命题](#命题-1)
  - [快速排序](#快速排序)
    - [特点](#特点-1)
    - [基本实现](#基本实现)
    - [改进实现](#改进实现)
  - [优先队列](#优先队列)
    - [特点](#特点-2)
    - [二叉堆](#二叉堆)
# 初级排序

## 插入排序

### 定义
+ 当前索引左边的所有元素都是有序的，但最终位置还不确定，插入排序所需的时间取决于输入中元素的初始顺序。
+ 插入排序对于实际应用中常见的某些类型的``非随机数组``比较有效

### 命题
+ 平均情况下插入排序需要``N^2/4次比较与交换``
+ 最坏情况下需要``N^2/2次比较与交换``
+ 最好情况下需要``N-1次交换和0次交换``
+ 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一
  + 每一次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，导致数量为0时，排序完成。

### 实现
```python
def insertsort(a):
    for i in range(1,len(a)):
        # 将a[i] 插入到 a[i-1],a[i-2],a[i-3]...中
        for j in range(i,0,-1):
            if a[j]<a[j-1]:
                a[j],a[j-1]=a[j-1],a[j]
```
+ 第一个for循环将每一个右边的元素插入进左边的有序区域
+ 第二个for循环针对被插入后的左边区域进行检索交换

### 优化
+ 在内循环(第二层循环)中，将较大的元素都向右移动而不总是交换两个元素，这样访问数组的次数就能减半

## 希尔排序

### 定义
+ 基于插入排序的快速的排序算法
  + 对于大规模乱序数组，插入排序很慢，因为只能一点一点地把元素从一端移动到另一端
+ 希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素来实现数组的局部排序，并最终用插入排序将局部有序的数组排序
+ 一个h有序数组就是h个互相独立的有序数组编织在一起组成的数组
+ 希尔排序的实现时通过在h子数组中将每个元素交换到比它大的元素之前去，只需要在插入排序的代码中将移动元素的距离由1改为h。

### 特点
+ 希尔排序可以用于大型数组，它对任意排序的数组表现也很好
+ 对于中等大小的数组，可以直接选用希尔排序，因为代码量很小，也不需要使用额外的内存空间

### 实现
```python
def ShellSort(a):
    N = len(a)
    h = 1
    while (h < N/3):
        h = 3*h + 1 # (1,4,13,40,121,364)
    while (h >= 1):
        # 将数组变为h有序
        for i in range(h,N):
            # 执行插入排序
            for j in range(i,h-1,-h):
                if(a[j] < a[j-h]):
                    a[j],a[j-h]=a[j-h],a[j]
        h = h // 3
```

## 归并排序
+ 归并: 将两个有序的数组归并成一个更大的有序数组

### 定义
+ 归并排序将数组递归地分成两半分别排序，然后将结果归并起来
+ 归并排序保证排序任意长度为N的数组时间运算复杂度为``NlogN``

### 原地归并
+ 将子数组a[lo..mid]和a[mid+1..hi]归并成一个有序的数组并存放在a[lo..hi]
+ 实现:
  + 如下代码中将所有的元素复制到aux[]中，然后再归并回a[]
  + 方法在归并时(第二个for循环)进行了四个条件判断:
    + 1. 左半边用尽，则取右半边的元素
    + 2. 右半边用尽，则取左半边的元素
    + 3. 右半边的当前元素小于左半边的当前元素，取右半边的元素
    + 4. 右半边的当前元素大于等于左半边的当前元素，取左半边的元素
```java
public static void merge(Comparable[] a, int lo, int mid, int hi)
{ // 将a[lo..mid] 和 a[mid+1..hi] 归并
 int i = lo, j = mid+1;
 for (int k = lo; k <= hi; k++) // 将a[lo..hi]复制到aux[lo..hi] 
    aux[k] = a[k];
 for (int k = lo; k <= hi; k++) // 归并回到a[lo..hi] 
    if (i > mid) a[k] = aux[j++]; 
    else if (j > hi ) a[k] = aux[i++]; 
    else if (less(aux[j], aux[i])) a[k] = aux[j++]; 
    else a[k] = aux[i++]; 
}
```

### 自顶向下的归并排序
+ 实现
```python
def sort(a)
    aux = a.copy()
    mergesort(a, 0, len(a)-1)

def mergesort(list a, int lo, int hi):
    if lo <= hi:
        return
    mid = lo + (hi - lo)/2
    mergesort(a, lo, mid)
    mergesort(a, mid+1, hi)
    merge(a, lo, mid, hi)
```
+ 优化：
  + 对小规模子数组使用插入排序
  + 测试数组是否已经有序

### 自底向上的归并排序
+ 首先进行两两归并(把每个元素想象成一个大小为1的数组)
+ 然后进行四四归并
+ 然后八八归并，一直进行下去
+ 在每一轮的归并中，最后一次归并的第二个子数组可能比第一个子数组小，否则就是相同，而下一轮中子数组的大小需要翻倍。

### 命题
+ 归并排序是一种渐进最优的基于比较排序的算法，运算复杂度NlogN

## 快速排序

### 特点
+ 原地排序，只需要一个很小的辅助栈，运算复杂度NlogN
+ 主要缺点：非常脆弱，在实现的时候要非常小心避免低劣的性能
+ 当切分不平衡时，这个程序可能会相当低效

### 基本实现
```python
def quicksort(a):
    if len(a)==0:
        return a
    x = a[0]
    left = [i for i in a[1:] if i<x]
    right = [i for i in a[1:] if i>=x]
    return quicksort(left) + [x] + quicksort(right)
```

### 改进实现
+ 1. 对于小数组，快速排序比插入排序慢，因为递归，快速排序的在小数组中也会调用自己
  + 针对此，在排序小数组时应该切换到插入排序
+ 2. 三取样切分，使用子数组的一小部分元素的中位数切分数组

## 优先队列

### 特点
+ 支持两种操作，删除最大元素和插入元素

### 二叉堆
+ 在堆有序的二叉树中，每个节点都小于等于它的父节点，从任意结点向上，我们都能得到一列非递减的元素，从任意节点向下，我们都能得到一列非递增的元素